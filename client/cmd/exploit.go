// Package cmd contains commands for the CookieFarm client
package cmd

import (
	"errors"
	"fmt"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"syscall"

	"github.com/ByteTheCookies/cookieclient/internal/api"
	"github.com/ByteTheCookies/cookieclient/internal/config"
	"github.com/ByteTheCookies/cookieclient/internal/executor"
	"github.com/ByteTheCookies/cookieclient/internal/filesystem"
	"github.com/ByteTheCookies/cookieclient/internal/logger"
	"github.com/ByteTheCookies/cookieclient/internal/submitter"
	"github.com/ByteTheCookies/cookieclient/internal/websockets"
	"github.com/rs/zerolog"
	"github.com/spf13/cobra"
)

// exploitCmd represents the main exploit command group
var exploitCmd = &cobra.Command{
	Use:   "exploit",
	Short: "Handling exploits and executing them in a loop",
	Long:  `This command allows you to handle exploits (execute, create, etc.). You can specify the exploit path, service port, and other parameters.`,
}

// attackCmd represents the run exploit command
var attackCmd = &cobra.Command{
	Use:   "run",
	Short: "Attack other teams with an exploit",
	Long:  `This command allows you to attack other teams with an exploit. You can specify the exploit path and the server host.`,
	Run:   attack,
}

// createCmd represents the create exploit command
var createCmd = &cobra.Command{
	Use:   "create",
	Short: "Generate a new exploit template",
	Long: `Generate a new exploit template for the CookieFarm client.
	This command initializes a structured exploit template file in your specified directory with all necessary components for immediate use.`,
	Run: Create,
}

// listCmd represents the list exploit command
var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all current running exploits",
	Long:  "This command lists all currently running exploits that are registered in the local configuration.",
	Run:   ListExploit,
}

// removeCmd represents the remove exploit command
var removeCmd = &cobra.Command{
	Use:   "remove",
	Short: "Remove an exploit template",
	Long:  `Remove an exploit template from the CookieFarm client.`,
	Run:   Remove,
}

// stopCmd represents the stop exploit command
var stopCmd = &cobra.Command{
	Use:   "stop",
	Short: "Stop the exploit execution",
	Long:  `This command stops the execution of the currently running exploit. It gracefully terminates the exploit process and cleans up any resources used during execution.`,
	Run:   stopExploit,
}

// Common variables
var (
	name string // Name of the exploit template for create command
	pid  int    // PID for the stop command
)

func init() {
	// Add exploitCmd to root command
	RootCmd.AddCommand(exploitCmd)

	// Add all subcommands to exploitCmd
	exploitCmd.AddCommand(attackCmd)
	exploitCmd.AddCommand(createCmd)
	exploitCmd.AddCommand(stopCmd)
	exploitCmd.AddCommand(listCmd)
	exploitCmd.AddCommand(removeCmd)

	// Setup flags for attackCmd (run)
	attackCmd.Flags().StringVarP(&config.ArgsAttackInstance.ExploitPath, "exploit", "e", "", "Path to the exploit file to execute")
	attackCmd.Flags().Uint16VarP(&config.ArgsAttackInstance.ServicePort, "port", "p", 0, "Service Port to attack")
	attackCmd.Flags().BoolVarP(&config.ArgsAttackInstance.Detach, "detach", "d", false, "Run the exploit in the background (detached mode)")
	attackCmd.Flags().IntVarP(&config.ArgsAttackInstance.TickTime, "tick", "t", 120, "Interval in seconds between exploit executions")
	attackCmd.Flags().IntVarP(&config.ArgsAttackInstance.ThreadCount, "thread", "T", 5, "Number of concurrent threads to run the exploit with")
	attackCmd.MarkFlagRequired("exploit")
	attackCmd.MarkFlagRequired("password")
	attackCmd.MarkFlagRequired("port")
	attackCmd.MarkFlagRequired("host")

	// Setup flags for createCmd
	createCmd.Flags().StringVarP(&name, "name", "n", "", "Name of the exploit template")
	createCmd.MarkFlagRequired("name")

	// Setup flags for removeCmd
	removeCmd.Flags().StringVarP(&name, "name", "n", "", "Name of the exploit template")
	removeCmd.MarkFlagRequired("name")

	// Setup flags for stopCmd
	stopCmd.Flags().IntVarP(&pid, "pid", "p", -1, "Pid to the exploit file to stop")
	stopCmd.MarkFlagRequired("pid")
}

// ===== RUN EXPLOIT FUNCTIONS =====

// SetupClient handles the full initialization process for the attack command
func setupClient() error {
	var err error

	err = config.LoadLocalConfig()
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error loading local configuration, try running `cookieclient config reset`")
		return err
	}

	if config.ArgsAttackInstance.Detach {
		fmt.Println(logger.Blue + "[INFO]" + logger.Reset + " | Detaching from terminal")
		Detach()
	}

	config.ArgsAttackInstance.ExploitPath, err = filesystem.NormalizeNamePathExploit(config.ArgsAttackInstance.ExploitPath)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error normalizing exploit name")
		return err
	}

	if !filesystem.IsPath(config.ArgsAttackInstance.ExploitPath) {
		exploitsDir := filepath.Join(config.DefaultConfigPath, "exploits")
		config.ArgsAttackInstance.ExploitPath = filepath.Join(exploitsDir, config.ArgsAttackInstance.ExploitPath)
	}

	logger.Log.Debug().Str("Exploit path", config.ArgsAttackInstance.ExploitPath).Msg("Using default exploit path")

	err = ValidateArgs(config.ArgsAttackInstance)
	if err != nil {
		return fmt.Errorf("invalid arguments: %w", err)
	}

	logger.Log.Debug().
		Int("ThreadCount", config.ArgsAttackInstance.ThreadCount).
		Int("Tick time", config.ArgsAttackInstance.TickTime).
		Str("ExploitPath", config.ArgsAttackInstance.ExploitPath).
		Msg("Arguments validated")

	config.Token, err = config.GetSession()
	if err != nil {
		return fmt.Errorf("failed to get session token: %w, try to run `cookieclient config login -P <password>`", err)
	}

	config.Current, err = api.GetConfig()
	if err != nil {
		return fmt.Errorf("failed to get config: %w", err)
	}

	logger.Log.Debug().Msgf("Current configuration: %+v", config.Current)

	if !config.Current.Configured {
		logger.Log.Fatal().Msg("Server not configured. Please run the configurator before using the client.")
	}

	return nil
}

// cleanupExploit removes an exploit from the configuration
func cleanupExploit(pid int) {
	for i, exploit := range config.ArgsConfigInstance.Exploits {
		if exploit.PID == pid {
			config.ArgsConfigInstance.Exploits = append(config.ArgsConfigInstance.Exploits[:i], config.ArgsConfigInstance.Exploits[i+1:]...)
			break
		}
	}
	if err := config.WriteConfig(); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to write configuration after exploit cleanup")
	}
}

// attack is the main execution flow for the attack command
func attack(cmd *cobra.Command, args []string) {
	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		logger.Log.Info().Msg("Shutting down gracefully...")
		if pid != 0 {
			cleanupExploit(pid)
		}
		os.Exit(0)
	}()

	if err := setupClient(); err != nil {
		if logger.LogLevel != zerolog.Disabled {
			logger.Log.Fatal().Err(err).Msg("Initialization error")
			logger.Close()
		} else {
			fmt.Println("Error initializing:", err)
		}
		os.Exit(1)
	}
	defer logger.Close()

	logger.Log.Info().Msg("Client initialized successfully")

	result, err := executor.Start(config.ArgsAttackInstance.ExploitPath, config.ArgsAttackInstance.TickTime, config.ArgsAttackInstance.ThreadCount, config.ArgsAttackInstance.ServicePort)
	if err != nil {
		logger.Log.Fatal().Err(err).Msg("Failed to execute exploit")
	}

	exploit := config.Exploit{
		Name: config.ArgsAttackInstance.ExploitPath,
		PID:  result.Cmd.Process.Pid,
	}
	config.ArgsConfigInstance.Exploits = append(config.ArgsConfigInstance.Exploits, exploit)
	if err := config.WriteConfig(); err != nil {
		logger.Log.Fatal().Err(err).Msg("Failed to write configuration with new exploit")
	}
	pid = result.Cmd.Process.Pid
	logger.Log.Info().Msg("Exploit started successfully")

	websockets.OnNewConfig = func() {
		executor.RestartGlobal()
	}

	go submitter.Start(result.FlagsChan)

	if err := result.Cmd.Wait(); err != nil {
		logger.Log.Error().Err(err).Msg("Exploit process exited with error")
	}
}

// Detach detaches the current process from the terminal by re-executing itself
func Detach() {
	cmd := exec.Command(os.Args[0], os.Args[1:]...)

	filteredArgs := []string{}
	for _, arg := range os.Args[1:] {
		if arg != "--detach" && arg != "-d" {
			filteredArgs = append(filteredArgs, arg)
		}
	}
	cmd = exec.Command(os.Args[0], filteredArgs...)

	cmd.Stdout = nil
	cmd.Stderr = nil
	cmd.Stdin = nil
	cmd.SysProcAttr = &syscall.SysProcAttr{Setsid: true}

	err := cmd.Start()
	if err != nil {
		fmt.Println(logger.Red+"[ERROR]"+logger.Reset+"| Error during detach:", err)
		os.Exit(1)
	}

	fmt.Println(logger.Yellow+"[WARN]"+logger.Reset+"| Process detached with PID:", cmd.Process.Pid)
	os.Exit(0)
}

// ValidateArgs validates the arguments passed to the program
func ValidateArgs(args config.ArgsAttack) error {
	if args.TickTime < 1 {
		return errors.New("tick time must be at least 1")
	}

	exploitPath, err := filepath.Abs(args.ExploitPath)
	if err != nil {
		return fmt.Errorf("error resolving exploit path: %v", err)
	}

	if info, err := os.Stat(exploitPath); err == nil && info.Mode()&0o111 == 0 {
		return errors.New("exploit file is not executable")
	}

	if _, err := os.Stat(exploitPath); os.IsNotExist(err) {
		return errors.New("exploit not found in the exploits directory")
	}

	return nil
}

// ===== CREATE EXPLOIT FUNCTIONS =====

// Create handles the creation of a new exploit template
func Create(cmd *cobra.Command, args []string) {
	path := config.DefaultConfigPath
	if _, err := os.Stat(config.DefaultConfigPath); os.IsNotExist(err) {
		logger.Log.Warn().Msg("Default exploit path not exists... Creating it")
		err := os.MkdirAll(config.DefaultConfigPath, os.ModePerm)
		if err != nil {
			logger.Log.Error().Err(err).Msg("Error creating exploit path")
			return
		}
	}

	logger.Log.Debug().Str("Exploit name", name).Msg("Creating exploit template")

	namePathNormalized, err := filesystem.NormalizeNamePathExploit(name)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error normalizing exploit name")
		return
	}

	if filesystem.IsPath(namePathNormalized) {
		path = namePathNormalized
	} else {
		exploitsDir := filepath.Join(path, "exploits")
		if _, err := os.Stat(exploitsDir); os.IsNotExist(err) {
			logger.Log.Warn().Msg("Exploits directory does not exist, creating it")
			os.Mkdir(exploitsDir, os.ModePerm)
		}
		path = filepath.Join(exploitsDir, namePathNormalized)
	}

	exploitFile, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_SYNC, 0o777)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error creating exploit file")
		return
	}
	exploitFile.Write(config.ExploitTemplate)
	defer exploitFile.Close()

	logger.Log.Info().Str("Exploit path", path).Msg("File created successfully")
}

// ===== LIST EXPLOIT FUNCTIONS =====

// ListExploit lists all currently running exploits
func ListExploit(cmd *cobra.Command, args []string) {
	err := config.LoadLocalConfig()
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error loading local configuration, try running `cookieclient config reset`")
		return
	}
	for i := 0; i < len(config.ArgsConfigInstance.Exploits); {
		exploit := config.ArgsConfigInstance.Exploits[i]
		proc, err := os.FindProcess(exploit.PID)
		if err != nil || proc == nil {
			logger.Log.Warn().Str("exploit", exploit.Name).Msg("Exploit removed due to invalid process")
			config.ArgsConfigInstance.Exploits = append(config.ArgsConfigInstance.Exploits[:i], config.ArgsConfigInstance.Exploits[i+1:]...)
			continue
		}
		err = proc.Signal(syscall.Signal(0))
		if err != nil {
			logger.Log.Warn().Str("exploit", exploit.Name).Msg("Exploit removed due to inactive process")
			config.ArgsConfigInstance.Exploits = append(config.ArgsConfigInstance.Exploits[:i], config.ArgsConfigInstance.Exploits[i+1:]...)
		} else {
			logger.Log.Info().Str("exploit", exploit.Name).Int("pid", exploit.PID).Msg("Available exploit")
			i++
		}
	}
	config.WriteConfig()
}

// ===== REMOVE EXPLOIT FUNCTIONS =====

// Remove handles the removal of an exploit template
func Remove(cmd *cobra.Command, args []string) {
	path := config.DefaultConfigPath
	if _, err := os.Stat(config.DefaultConfigPath); os.IsNotExist(err) {
		logger.Log.Warn().Msg("Default exploit path not exists... Creating it")
		err := os.MkdirAll(config.DefaultConfigPath, os.ModePerm)
		if err != nil {
			logger.Log.Error().Err(err).Msg("Error removing exploit path")
			return
		}
	}

	logger.Log.Debug().Str("Exploit name", name).Msg("Removing exploit template")

	namePathNormalized, err := filesystem.NormalizeNamePathExploit(name)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error normalizing exploit name")
		return
	}

	if filesystem.IsPath(namePathNormalized) {
		path = namePathNormalized
	} else {
		exploitsDir := filepath.Join(path, "exploits")
		if _, err := os.Stat(exploitsDir); os.IsNotExist(err) {
			logger.Log.Warn().Msg("Exploits directory does not exist, creating it")
			os.Mkdir(exploitsDir, os.ModePerm)
		}
		path = filepath.Join(exploitsDir, namePathNormalized)
	}

	err = os.Remove(path)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error removing exploit file")
		return
	}

	logger.Log.Info().Str("Exploit path", path).Msg("File removed successfully")
}

// ===== STOP EXPLOIT FUNCTIONS =====

// stopExploit stops a running exploit by PID
func stopExploit(cmd *cobra.Command, args []string) {
	if err := config.LoadLocalConfig(); err != nil {
		logger.Log.Error().Err(err).Msg("Error loading local configuration, try running `cookieclient config reset`")
		return
	}

	for i, exploit := range config.ArgsConfigInstance.Exploits {
		logger.Log.Info().Str("Exploit", exploit.Name).Msg("Stopping exploit")
		if exploit.PID == pid {
			proc, err := os.FindProcess(exploit.PID)
			if err != nil {
				logger.Log.Error().Err(err).Msg("Error finding process")
				return
			}
			err = proc.Kill()
			if err != nil {
				logger.Log.Error().Err(err).Msg("Error stopping exploit")
				return
			}
			config.ArgsConfigInstance.Exploits = append(config.ArgsConfigInstance.Exploits[:i], config.ArgsConfigInstance.Exploits[i+1:]...)
			config.WriteConfig()
			logger.Log.Info().Str("Exploit", exploit.Name).Msg("Exploit stopped successfully")
			return
		}
	}
	logger.Log.Warn().Msg("No exploit found with the specified PID")
}

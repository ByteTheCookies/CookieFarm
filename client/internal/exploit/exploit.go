package exploit

import (
	"errors"
	"fmt"
	"os"
	"os/signal"
	"path/filepath"
	"slices"
	"syscall"

	"github.com/ByteTheCookies/cookieclient/internal/config"
	"github.com/ByteTheCookies/cookieclient/internal/executor"
	"github.com/ByteTheCookies/cookieclient/internal/filesystem"
	"github.com/ByteTheCookies/cookieclient/internal/logger"
	"github.com/ByteTheCookies/cookieclient/internal/submitter"
	"github.com/ByteTheCookies/cookieclient/internal/websockets"
)

// StreamingResult contains the result channels for RunFuncTui
type StreamingResult struct {
	OutputChan chan string
	ErrorChan  chan error
	ExitChan   chan struct{}
	PID        int
}

func Run(exploitName string, ticktime int, threads int, servicePort uint16, detach bool) (*StreamingResult, error) {
	config.ArgsAttackInstance.ExploitPath = exploitName
	config.ArgsAttackInstance.TickTime = ticktime
	config.ArgsAttackInstance.ThreadCount = threads
	config.ArgsAttackInstance.ServicePort = servicePort

	outputChan := make(chan string, 100) // Buffer for output messages
	errorChan := make(chan error, 10)    // Buffer for errors
	exitChan := make(chan struct{})      // Signal when process exits

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		logger.Log.Info().Msg("Shutting down gracefully...")
		if config.PID != 0 {
			Cleanup(config.PID)
		}
		close(exitChan)
	}()

	// Initialize exploit environment
	if err := Setup(detach); err != nil {
		logger.Log.Error().Err(err).Msg("Initialization error")
		return nil, fmt.Errorf("initialization error: %v", err)
	}

	// Send initialization message to output channel
	outputChan <- "Client initialized successfully"
	logger.Log.Info().Msg("Client initialized successfully")

	// Start the exploit process with output capture
	result, err := executor.Start(
		config.ArgsAttackInstance.ExploitPath,
		config.ArgsAttackInstance.TickTime,
		config.ArgsAttackInstance.ThreadCount,
		config.ArgsAttackInstance.ServicePort,
	)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Failed to execute exploit")
		return nil, fmt.Errorf("failed to execute exploit: %v", err)
	}

	// Register exploit in configuration
	exploitS := config.Exploit{
		Name: exploitName,
		PID:  result.Cmd.Process.Pid,
	}
	config.ArgsConfigInstance.Exploits = append(config.ArgsConfigInstance.Exploits, exploitS)
	if err := config.WriteConfig(); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to write configuration")
		return nil, fmt.Errorf("failed to write configuration: %v", err)
	}

	// Save PID for reference
	config.PID = result.Cmd.Process.Pid

	// Forward startup information to the output channel
	outputChan <- fmt.Sprintf("Exploit started with PID: %d", config.PID)
	outputChan <- fmt.Sprintf("Running on port %d: %s", servicePort, config.MapPortToService(servicePort))
	outputChan <- fmt.Sprintf("Threads: %d, Tick time: %d seconds", threads, ticktime)
	outputChan <- "Output streaming started..."

	// Setup websocket handler for configuration updates
	websockets.OnNewConfig = func() {
		executor.RestartGlobal()
		outputChan <- "Configuration updated, restarting exploit..."
	}

	// Start flag submission in background
	go submitter.Start(result.FlagsChan)

	// Forward output from result.OutputChan to our outputChan
	go func() {
		defer close(outputChan)
		defer close(errorChan)
		defer close(exitChan)

		for {
			select {
			case line, ok := <-result.OutputChan:
				if !ok {
					outputChan <- "Output channel closed"
					return
				}
				outputChan <- line
			case <-exitChan:
				return
			}
		}
	}()

	// Start the command in background and monitor for errors
	go func() {
		if err := result.Cmd.Wait(); err != nil {
			errorMsg := fmt.Sprintf("Exploit process exited with error: %v", err)
			logger.Log.Error().Err(err).Msg("Exploit process exited with error")
			errorChan <- errors.New(errorMsg)
			outputChan <- "ERROR: " + errorMsg
		} else {
			outputChan <- "Exploit process completed successfully"
		}
		exitChan <- struct{}{}
	}()

	// Return the streaming result with channels
	return &StreamingResult{
		OutputChan: outputChan,
		ErrorChan:  errorChan,
		ExitChan:   exitChan,
		PID:        config.PID,
	}, nil
}

func Create(name string) (string, error) {
	path := config.DefaultConfigPath
	if _, err := os.Stat(config.DefaultConfigPath); os.IsNotExist(err) {
		logger.Log.Warn().Msg("Default exploit path not exists... Creating it")
		err := os.MkdirAll(config.DefaultConfigPath, os.ModePerm)
		if err != nil {
			return "", fmt.Errorf("error creating exploit path: %v", err)
		}
	}

	logger.Log.Debug().Str("Exploit name", name).Msg("Creating exploit template")

	namePathNormalized, err := filesystem.NormalizeNamePathExploit(name)
	if err != nil {
		return "", fmt.Errorf("error normalizing exploit name: %v", err)
	}

	if filesystem.IsPath(namePathNormalized) {
		path = namePathNormalized
	} else {
		exploitsDir := filepath.Join(path, "exploits")
		if _, err := os.Stat(exploitsDir); os.IsNotExist(err) {
			logger.Log.Warn().Msg("Exploits directory does not exist, creating it")
			os.Mkdir(exploitsDir, os.ModePerm)
		}
		path = filepath.Join(exploitsDir, namePathNormalized)
	}

	exploitFile, err := os.OpenFile(path, os.O_CREATE|os.O_WRONLY|os.O_SYNC, 0o777)
	if err != nil {
		return "", fmt.Errorf("error creating exploit file: %v", err)
	}
	exploitFile.Write(config.ExploitTemplate)
	defer exploitFile.Close()

	return "Exploit file created successfully at " + path, nil
}

func Remove(name string) (string, error) {
	path := config.DefaultConfigPath
	if _, err := os.Stat(config.DefaultConfigPath); os.IsNotExist(err) {
		logger.Log.Warn().Msg("Default exploit path not exists... Creating it")
		err := os.MkdirAll(config.DefaultConfigPath, os.ModePerm)
		if err != nil {
			return "", fmt.Errorf("error removing exploit path: %v", err)
		}
	}

	logger.Log.Debug().Str("Exploit name", name).Msg("Removing exploit template")

	namePathNormalized, err := filesystem.NormalizeNamePathExploit(name)
	if err != nil {
		return "", fmt.Errorf("error normalizing exploit name: %v", err)
	}

	if filesystem.IsPath(namePathNormalized) {
		path = namePathNormalized
	} else {
		exploitsDir := filepath.Join(path, "exploits")
		if _, err := os.Stat(exploitsDir); os.IsNotExist(err) {
			logger.Log.Warn().Msg("Exploits directory does not exist, creating it")
			os.Mkdir(exploitsDir, os.ModePerm)
		}
		path = filepath.Join(exploitsDir, namePathNormalized)
	}

	if _, err := os.Stat(path); os.IsNotExist(err) {
		return "", fmt.Errorf("exploit file does not exist: %s", path)
	}

	err = os.Remove(path)
	if err != nil {
		return "", fmt.Errorf("error removing exploit file: %v", err)
	}

	return "Exploit file removed successfully: " + path, nil
}

func Stop(pid int) (string, error) {
	if err := config.LoadLocalConfig(); err != nil {
		return "", err
	}

	for i, exploitS := range config.ArgsConfigInstance.Exploits {
		logger.Log.Info().Str("Exploit", exploitS.Name).Msg("Stopping exploit")
		if exploitS.PID == pid {
			proc, err := os.FindProcess(exploitS.PID)
			if err != nil {
				return "", err
			}
			err = proc.Kill()
			if err != nil {
				logger.Log.Error().Err(err).Msg("Error stopping exploit")
				return "", err
			}
			config.ArgsConfigInstance.Exploits = slices.Delete(config.ArgsConfigInstance.Exploits, i, i+1)
			config.WriteConfig()
			return "Exploit stopped successfully: " + exploitS.Name, nil
		}
	}
	logger.Log.Warn().Msg("No exploit found with the specified PID")
	return "", fmt.Errorf("no exploit found with PID %d", config.PID)
}

from tty import IFLAG
import logging
from re import I
import requests
from typing import Optional


logger = logging.getLogger("ckfrm_loggger")

# class Server:
#     """
#     Manages server IP, credentials, and token-based authentication.
#     Supports validation and token generation for HTTP requests.
#     """

#     def __init__(self, address: str = "", password: str = "",
#                  token_path: str = "/api/v1/auth/login"):
#         self._address = None
#         self._password = None
#         self._token = None
#         self._token_path = token_path

#         if address is not None:
#             self.address = address
#         if password is not None:
#             self.password = password

#         if address is not None and password is not None:
#             self.token = self._generate_token(path=self._token_path)

#     # ----- Properties -----
#     @property
#     def address(self) -> Optional[str]:
#         return self._address

#     @property
#     def password(self) -> Optional[str]:
#         return self._password

#     @property
#     def token(self) -> Optional[str]:
#         return self._token

#     # ----- Setters -----
#     @address.setter
#     def address(self, value: str):
#         if not self._validate_ip(value):
#             raise ValueError("Invalid IP address")
#         self._address = value

#         if self._token:
#             self.token = self._generate_token(path=self._token_path)  # Reset token

#     @password.setter
#     def password(self, value: str):
#         if not self._validate_password(value):
#             raise ValueError("Invalid password")
#         self._password = value

#         if self._token:
#             self.token = self._generate_token(path=self._token_path)  # Reset token

#     @token.setter
#     def token(self, value: str):
#         if not self._validate_token(value):
#             raise ValueError("Invalid token")
#         self._token = value

#     # ----- Validation -----
#     def _validate_ip(self, ip: str) -> bool:
#         """
#         Validate IP string format.

#         Parameters:
#         ip (str): The IP address to validate.
#         """
#         if not isinstance(ip, str):
#             raise TypeError("IP address must be a string")
#         if not ip:
#             raise ValueError("IP address cannot be empty")
#         if not ip.startswith("http://"):
#             raise ValueError("IP address must start with http://")
#         return True

#     def _validate_password(self, password: str) -> bool:
#         """
#         Validate password input format.

#         Parameters:
#         password (str): The password to validate.
#         """
#         if not isinstance(password, str):
#             raise TypeError("Password must be a string")
#         if not password:
#             raise ValueError("Password cannot be empty")
#         return True

#     def _validate_token(self, token: str) -> bool:
#         """
#         Validate token input format.

#         Parameters:
#         token (str): The token to validate.
#         """
#         if not isinstance(token, str):
#             raise TypeError("Token must be a string")
#         if not token:
#             raise ValueError("Token cannot be empty")
#         return True

#     # ----- Methods -----
#     def _generate_token(self, path: str = "/") -> str:
#         """
#         Request and return token from server.

#         Parameters:
#         path (str): API path for token generation.

#         Returns:
#         str: Authentication token.
#         """
#         auth_data = {"password": self.password}

#         r = requests.post(f"{self.address}{path}", data=auth_data)
#         if not r.ok:
#             raise ValueError("Failed to generate token")

#         logger.info(f"Generated token: {r.json()['token']}")

#         return r.json()["token"]

#     def get_ip_teams(self, path: str = "/") -> list[str]:
#         """
#         Get all team IPs except own.

#         Parameters:
#         path (str): API path to retrieve team IP configuration.

#         Returns:
#         list[str]: List of team IPs excluding current team IP.
#         """
#         headers = {"Authorization": f"Bearer {self.token}"}

#         r = requests.get(f"{self.address}/{path}", headers=headers)
#         if not r.ok:
#             raise ValueError("Failed to get config")

#         logger.info(f"Get configuration from Server {self.address}")

#         config_json = r.json()

#         if not config_json["client"]["format_ip_teams"]:
#             raise ValueError("Format IP teams is not configured")
#         format_ip_teams = config_json["client"]["format_ip_teams"]
#         logger.debug(f"Format IP teams: {format_ip_teams}")

#         if not config_json["client"]["range_ip_teams"]:
#             raise ValueError("Range IP teams is not configured")
#         range_ip_teams = int(config_json["client"]["range_ip_teams"])
#         logger.debug(f"Range IP teams: {range_ip_teams}")

#         if not config_json["client"]["my_team_ip"]:
#             raise ValueError("My team IP is not configured")
#         my_team_ip = config_json["client"]["my_team_ip"]
#         logger.debug(f"My team IP: {my_team_ip}")

#         ip_teams = [
#             format_ip_teams.format(i)
#             for i in range(range_ip_teams + 1)
#         ]

#         if my_team_ip in ip_teams:
#             ip_teams.remove(my_team_ip)

#         logger.debug(f"IP teams: {ip_teams}")

#         return ip_teams

# ------------------------------------------------------------------------

def get_auth_session(server_address:str, password:str, auth_api_path:str = "/api/v1/auth") -> requests.Session:
    session = requests.Session()
    session.
    return session

def get_ip_teams(server_address:str, password:str, config_api_path:str = "/api/v1/config") -> list[str]:
    session = get_auth_session(server_address, password)

    r:requests.Response = session.get(f"{server}/{path}")
    if not r.ok:
        raise ValueError("Failed to get config")

    config_json = r.json()

    return [
        config_json["client"]["format_ip_teams"].format(i)
        for i in range(int(config_json["client"]["range_ip_teams"]) + 1)
        if i != int(config_json["client"]["my_team_ip"].split(".")[2])
    ]

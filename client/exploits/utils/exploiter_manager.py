"""
    Exploit Manager
    This module manages the exploit process by handling authentication,
    configuration retrieval, and dispatching exploits to the target IP teams.

"""

from sys import argv
from array import array
from time import time, sleep
from requests import post, get
from asyncio import gather, run, to_thread, get_running_loop
from re import compile, Pattern
from typing import Any
from concurrent.futures import ThreadPoolExecutor
from .logger import StatusCode, log_status


def get_auth_token(
    server_address: str, password: str, auth_api_path: str = "/api/v1/auth/login"
) -> str:
    """
    Get the authentication token from the server.

    Args:
        server_address (str): The address of the server.
        password (str): The password to authenticate.
        auth_api_path (str): The API path for authentication.
    Returns:
        str: The authentication token.
    Raises:
        ValueError: If the response from the server is not ok.
    """

    response = post(f"{server_address}{auth_api_path}", data={"password": password})
    if not response.ok:
        log_status(StatusCode.FATAL, "Failed to get auth")
        exit(1)

    return response.cookies["token"]


def get_ip_teams(
    server_address: str, password: str, config_api_path: str = "/api/v1/config"
) -> tuple[array[int], str]:
    """
    Get the IP teams from the server.

    Args:
        server_address (str): The address of the server.
        password (str): The password to authenticate.
        config_api_path (str): The API path for configuration.
    Returns:
        tuple[array[int], str]: A tuple containing an array of IP teams and the format of IP teams.
    Raises:
        ValueError: If the response from the server is not ok.
    """

    response = get(
        f"{server_address}{config_api_path}",
        headers={
            "Content-Type": "application/json",
            "Cookie": f"token={get_auth_token(server_address=server_address, password=password)}",
        },
    )
    if not response.ok:
        log_status(StatusCode.FATAL, "Failed to get config")
        exit(1)

    config_json = response.json()

    my_ip_team = int(config_json["client"]["my_team_ip"].split(".")[2])
    ip_teams = array("H", range(my_ip_team))

    for i in range(my_ip_team + 1, int(config_json["client"]["range_ip_teams"]) + 1):
        ip_teams.append(i)

    return ip_teams, config_json["client"]["format_ip_teams"]


def extract_flag(source: str | list[str], regex: Pattern) -> list[str|Any]:
    """
    Extract flags from the source using the provided regex.

    Args:
        source (str|list[str]): The source string or list of strings to extract flags from.
        regex (Pattern): The regex pattern to match the flags.
    Returns:
        list[str]: A list of extracted flags.
    Raises:
        ValueError: If the source is empty or if the regex does not match.
        TypeError: If the source is not a string or a list of strings.
    """

    if not source:
        log_status(StatusCode.ERROR, "Source cannot be empty")
        return []

    if isinstance(source, list):
        if not all(isinstance(item, str) for item in source):
            log_status(StatusCode.ERROR, "All items in the list must be strings")
            return []

        return [match for item in source for match in regex.findall(item)]

    if not isinstance(source, str):
        log_status(StatusCode.ERROR, "Source must be a string or a list of strings")
        return []

    if not regex.match(source):
        return []

    return regex.findall(source)


async def execute_exploit(
    exploit_function, ip_team: str, port_service: int, regex: Pattern
) -> tuple[str, list[str]]:
    """
    Execute the exploit function asynchronously for the specified IP team and port service.

    This function runs the provided exploit function in a separate thread using asyncio's to_thread,
    allowing non-blocking execution. It then extracts any flags from the exploit's output
    using the provided regex pattern.

    Args:
        exploit_function (function): The exploit function to be dispatched.
        ip_team (str): The IP team to target.
        port_service (int): The port service to target.
        regex (Pattern): The regex pattern to match the flags.
    Returns:
        tuple[str, list[str]]: A tuple containing the IP team and a list of extracted flags.
    """
    try:
        exploit = await to_thread(exploit_function, ip_team, port_service)
    except Exception as e:
        log_status(StatusCode.ERROR, str(e), team_id=int(ip_team.split(".")[2]), port_service=port_service)
        return ip_team, []

    return ip_team, extract_flag(exploit, regex)


async def dispatch_exploits(
    exploit_function,
    ip_teams: array[int],
    ip_format: str,
    port_service: int,
    regex: Pattern,
    thread_number: int
):
    """
    Dispatch the exploits for the given IP teams and port service.
    Print the results in JSON format in standard output.

    Args:
        exploit_function (function): The exploit function to be executed.
        ip_teams (array[int]): The array of IP teams to target.
        ip_format (str): The format of the IP teams.
        port_service (int): The port service to target.
        regex (Pattern): The regex pattern to match the flags.
        thread_number (int): The number of threads to use for the attack.
    """
    executor = ThreadPoolExecutor(max_workers=thread_number)

    loop = get_running_loop()
    loop.set_default_executor(executor)

    results = await gather(*[
           execute_exploit(
               exploit_function=exploit_function,
               ip_team=ip_format.format(ip_team),
               port_service=port_service,
               regex=regex
           )
           for ip_team in ip_teams
       ])

    for result in results:
        if result[1] == []:
            log_status(
                StatusCode.FAILED,
                "No flags found",
                team_id=int(result[0].split(".")[2]),
                port_service=port_service,
            )

        for flag in result[1]:
            log_status(
                StatusCode.SUCCESS,
                "Flag Found",
                team_id=int(result[0].split(".")[2]),
                port_service=port_service,
                flag_code=flag
            )


def attack_loop(
    exploit_function,
    ip_teams: array[int],
    ip_format: str,
    port_service: int,
    flag_regex: Pattern,
    tick_time: int,
    thread_number: int,
):
    """
    Run the exploit function in a loop with a specified tick time.

    Args:
        exploit_function (function): The exploit function to be executed.
        ip_teams (array[int]): The array of IP teams to target.
        ip_format (str): The format of the IP teams.
        port_service (int): The port service to target.
        flag_regex (Pattern): The regex pattern to match the flags.
        tick_time (int): The time interval between each execution of the exploit function.
        thread_number (int): The number of threads to use for the attack.
    """

    while True:
        start_time = time()

        run(
            dispatch_exploits(
                exploit_function=exploit_function,
                ip_teams=ip_teams,
                ip_format=ip_format,
                port_service=port_service,
                regex=flag_regex,
                thread_number=thread_number
            )
        )

        elapsed_time = time() - start_time
        sleep_time = max(0, tick_time - elapsed_time)
        sleep(sleep_time)


def exploit_manager(func):
    """
    Decorator to manage the exploit process.
    """

    def wrapper(*_args, **kwargs):
        if "port" not in kwargs:
            raise ValueError("Port is required")

        ip_teams, ip_format = get_ip_teams(server_address=argv[1], password=argv[2])
        attack_loop(
            exploit_function=func,
            ip_teams=ip_teams,
            ip_format=ip_format,
            port_service=kwargs["port"],
            flag_regex=compile(argv[4]),
            tick_time=int(argv[3]),
            thread_number=int(argv[5])
        )

    return wrapper

from asyncio import gather,run
from sys import argv
from time import time,sleep

from json import dumps
from array import array
from requests import post, get
from re import compile, Pattern


def get_auth_token(server_address:str, password:str, auth_api_path:str = "/api/v1/auth/login") -> str:
    response = post(f"{server_address}{auth_api_path}", data={"password": password})
    if not response.ok:
        raise ValueError("Failed to get auth")

    return response.cookies['token']

def get_ip_teams(server_address:str, password:str, config_api_path:str = "/api/v1/config") -> tuple[array[int], str]:
    response = get(
        f"{server_address}{config_api_path}",
        headers={
            'Content-Type': 'application/json',
            'Cookie': f"token={get_auth_token(server_address=server_address, password=password)}"
        }
    )
    if not response.ok:
        raise ValueError("Failed to get config")

    config_json = response.json()

    my_ip_team = int(config_json["client"]["my_team_ip"].split(".")[2])
    ip_teams = array("H", range(my_ip_team))

    for i in range(my_ip_team + 1, int(config_json["client"]["range_ip_teams"]) + 1):
        ip_teams.append(i)

    return ip_teams, config_json["client"]["format_ip_teams"]

def get_flag_from_multisource(source:str|list[str], regex: Pattern) -> list[str]:
    if not source:
        raise ValueError("Source cannot be empty")

    if isinstance(source, list):
        if not all(isinstance(item, str) for item in source):
            raise ValueError("All items in the list must be strings")

        return [regex.findall(item) for item in source if regex.search(item)]

    if not isinstance(source, str):
        raise TypeError("Source must be a string or a list of strings")

    return regex.findall(source)

async def dispatch_exploit(exploit_function, ip_team:str, port_service:int, regex: Pattern) -> tuple[str, list[str]]:
    return ip_team, get_flag_from_multisource(exploit_function(ip_team, port_service), regex)

async def dispatch_exploits(
    exploit_function,
    ip_teams:array[int],
    ip_format:str,
    port_service:int,
    regex: Pattern
):

    results = await gather(*[dispatch_exploit(exploit_function, ip_format.format(ip_team), port_service, regex) for ip_team in ip_teams])

    for result in results:
        for flag in result[1]:
            print(
                dumps({"team_id": int(result[0].split('.')[2]), "service_port": port_service, "flag_code": flag}),
                flush=True
            )

def attack(
    exploit_function,
    ip_teams:array[int],
    ip_format:str,
    port_service:int,
    flag_regex:Pattern,
    tick_time:int
):
    while True:
        start_time = time()

        run(dispatch_exploits(exploit_function, ip_teams, ip_format, port_service, flag_regex))

        elapsed_time = time() - start_time
        sleep_time = max(0, tick_time - elapsed_time)
        sleep(sleep_time)

def exploit_manager(func):
    def wrapper(*_args, **kwargs):
        if 'port' not in kwargs:
            raise ValueError("Port is required")

        ip_teams, ip_format = get_ip_teams(server_address=argv[1], password=argv[2])

        attack(
            exploit_function=func,
            ip_teams=ip_teams,
            ip_format=ip_format,
            port_service=kwargs['port'],
            flag_regex=compile(argv[4]),
            tick_time=int(argv[3])
        )
    return wrapper

"""
    Exploit Manager
    This module manages the exploit process by handling authentication,
    configuration retrieval, and dispatching exploits to the target IP teams.

"""


from sys import argv
from json import dumps
from array import array
from time import time, sleep
from requests import post, get
from asyncio import gather, run, to_thread
from re import compile, Pattern
from typing import Any


def get_auth_token(
    server_address: str, password: str, auth_api_path: str = "/api/v1/auth/login"
) -> str:
    """
    Get the authentication token from the server.

    Args:
        server_address (str): The address of the server.
        password (str): The password to authenticate.
        auth_api_path (str): The API path for authentication.
    Returns:
        str: The authentication token.
    Raises:
        ValueError: If the response from the server is not ok.
    """

    response = post(f"{server_address}{auth_api_path}", data={"password": password})
    if not response.ok:
        raise ValueError("Failed to get auth")

    return response.cookies["token"]


def get_ip_teams(
    server_address: str, password: str, config_api_path: str = "/api/v1/config"
) -> tuple[array[int], str]:
    """
    Get the IP teams from the server.

    Args:
        server_address (str): The address of the server.
        password (str): The password to authenticate.
        config_api_path (str): The API path for configuration.
    Returns:
        tuple[array[int], str]: A tuple containing an array of IP teams and the format of IP teams.
    Raises:
        ValueError: If the response from the server is not ok.
    """

    response = get(
        f"{server_address}{config_api_path}",
        headers={
            "Content-Type": "application/json",
            "Cookie": f"token={get_auth_token(server_address=server_address, password=password)}",
        },
    )
    if not response.ok:
        raise ValueError("Failed to get config")

    config_json = response.json()

    my_ip_team = int(config_json["client"]["my_team_ip"].split(".")[2])
    ip_teams = array("H", range(my_ip_team))

    for i in range(my_ip_team + 1, int(config_json["client"]["range_ip_teams"]) + 1):
        ip_teams.append(i)

    return ip_teams, config_json["client"]["format_ip_teams"]


def extract_flag(source: str | list[str], regex: Pattern) -> list[str|Any]:
    """
    Extract flags from the source using the provided regex.

    Args:
        source (str|list[str]): The source string or list of strings to extract flags from.
        regex (Pattern): The regex pattern to match the flags.
    Returns:
        list[str]: A list of extracted flags.
    Raises:
        ValueError: If the source is empty or if the regex does not match.
        TypeError: If the source is not a string or a list of strings.
    """

    if not source:
        raise ValueError("Source cannot be empty")

    if isinstance(source, list):
        if not all(isinstance(item, str) for item in source):
            raise ValueError("All items in the list must be strings")

        return [match for item in source for match in regex.findall(item)]

    if not isinstance(source, str):
        raise TypeError("Source must be a string or a list of strings")

    return regex.findall(source)


async def execute_exploit(
    exploit_function, ip_team: str, port_service: int, regex: Pattern
) -> tuple[str, list[str]]:
    """
    Execute the exploit function asynchronously for the specified IP team and port service.

    This function runs the provided exploit function in a separate thread using asyncio's to_thread,
    allowing non-blocking execution. It then extracts any flags from the exploit's output
    using the provided regex pattern.

    Args:
        exploit_function (function): The exploit function to be dispatched.
        ip_team (str): The IP team to target.
        port_service (int): The port service to target.
        regex (Pattern): The regex pattern to match the flags.
    Returns:
        tuple[str, list[str]]: A tuple containing the IP team and a list of extracted flags.
    """
    return ip_team, extract_flag(await to_thread(exploit_function, ip_team, port_service), regex)


async def dispatch_exploits(
    exploit_function,
    ip_teams: array[int],
    ip_format: str,
    port_service: int,
    regex: Pattern,
):
    """
    Dispatch the exploits for the given IP teams and port service.
    Print the results in JSON format in standard output.

    Args:
        exploit_function (function): The exploit function to be executed.
        ip_teams (array[int]): The array of IP teams to target.
        ip_format (str): The format of the IP teams.
        port_service (int): The port service to target.
        regex (Pattern): The regex pattern to match the flags.
    """

    results = await gather(*[
           execute_exploit(
               exploit_function=exploit_function,
               ip_team=ip_format.format(ip_team),
               port_service=port_service,
               regex=regex
           )
           for ip_team in ip_teams
       ])

    for result in results:
        for flag in result[1]:
            print(
                dumps(
                    {
                        "team_id": int(result[0].split(".")[2]),
                        "service_port": port_service,
                        "flag_code": flag,
                    }
                ),
                flush=True,
            )


def attack_loop(
    exploit_function,
    ip_teams: array[int],
    ip_format: str,
    port_service: int,
    flag_regex: Pattern,
    tick_time: int,
):
    """
    Run the exploit function in a loop with a specified tick time.

    Args:
        exploit_function (function): The exploit function to be executed.
        ip_teams (array[int]): The array of IP teams to target.
        ip_format (str): The format of the IP teams.
        port_service (int): The port service to target.
        flag_regex (Pattern): The regex pattern to match the flags.
        tick_time (int): The time interval between each execution of the exploit function.
    """

    while True:
        start_time = time()

        run(
            dispatch_exploits(
                exploit_function=exploit_function,
                ip_teams=ip_teams,
                ip_format=ip_format,
                port_service=port_service,
                regex=flag_regex
            )
        )

        elapsed_time = time() - start_time
        sleep_time = max(0, tick_time - elapsed_time)
        sleep(sleep_time)


def exploit_manager(func):
    """
    Decorator to manage the exploit process.
    """

    def wrapper(*_args, **kwargs):
        if "port" not in kwargs:
            raise ValueError("Port is required")

        ip_teams, ip_format = get_ip_teams(server_address=argv[1], password=argv[2])

        attack_loop(
            exploit_function=func,
            ip_teams=ip_teams,
            ip_format=ip_format,
            port_service=kwargs["port"],
            flag_regex=compile(argv[4]),
            tick_time=int(argv[3]),
        )

    return wrapper

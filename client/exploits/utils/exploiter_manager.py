import sys
import json
import time
import asyncio

from typing import Callable
from requests import post, get
from re import compile, Pattern
# from memory_profiler import profile


# Batch option

# @profile
def get_auth_token(server_address:str, password:str, auth_api_path:str = "/api/v1/auth/login") -> str:
    response = post(f"{server_address}{auth_api_path}", data={"password": password})
    if not response.ok:
        raise ValueError("Failed to get auth")

    return response.cookies['token']

def get_ip_teams(server_address:str, password:str, config_api_path:str = "/api/v1/config") -> set[str]:
    response = get(
        f"{server_address}{config_api_path}",
        headers={
            'Content-Type': 'application/json',
            'Cookie': f"token={get_auth_token(server_address=server_address, password=password)}"
        }
    )
    if not response.ok:
        raise ValueError("Failed to get config")

    config_json = response.json()

    return {
        config_json["client"]["format_ip_teams"].format(i)
        for i in range(int(config_json["client"]["range_ip_teams"]) + 1)
        if i != int(config_json["client"]["my_team_ip"].split(".")[2])
    }

def get_flag_from_multisource(source:str|list[str], regex: Pattern) -> list[str]:
    if not source:
        raise ValueError("Source cannot be empty")

    if isinstance(source, list):
        if not all(isinstance(item, str) for item in source):
            raise ValueError("All items in the list must be strings")

        if not all(regex.match(item) for item in source):
            raise ValueError("All items in the list must match the flag regex")

        return source

    if not isinstance(source, str):
        raise TypeError("Source must be a string or a list of strings")

    return regex.findall(source)

async def dispatch_exploit(exploit_function:Callable, ip_team:str, port_service:int, regex: Pattern) -> tuple[str, list[str]]:
    return ip_team, get_flag_from_multisource(exploit_function(ip_team, port_service), regex)

async def dispatch_exploits(
    exploit_function:Callable,
    ip_teams:set[str],
    port_service:int,
    regex: Pattern
):
    results = await asyncio.gather(*[dispatch_exploit(exploit_function, ip_team, port_service, regex) for ip_team in ip_teams])
    for result in results:
        for flag in result[1]:
            print(
                json.dumps({
                    'team_id': int(result[0].split('.')[2]),
                    'service_port': port_service,
                    'flag_code': flag
                }),
                flush=True
            )

def attack(
    exploit_function:Callable,
    ip_teams:set[str],
    port_service:int,
    flag_regex:Pattern,
    tick_time:int
):
    while True:
        start_time = time.time()

        asyncio.run(dispatch_exploits(exploit_function, ip_teams, port_service, flag_regex))

        elapsed_time = time.time() - start_time
        sleep_time = max(0, tick_time - elapsed_time)
        time.sleep(sleep_time)

def exploit_manager(func):
    def wrapper(*args, **kwargs):
        if 'port' not in kwargs:
            raise ValueError("Port is required")

        attack(
            exploit_function=func,
            ip_teams=get_ip_teams(
                server_address=sys.argv[1],
                password=sys.argv[2]
            ),
            port_service=kwargs['port'],
            flag_regex=compile(sys.argv[4]),
            tick_time=int(sys.argv[3])
        )
    return wrapper

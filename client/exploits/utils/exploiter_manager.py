#!../../../venv/bin/python3

import requests
import json

# TODO: Implement get flag from every web source (text or html page)
# TODO: Implement number of threads to use
# TODO: Implement of number of secondo to run the exploit
# TODO: Implement class for manageing exploit, server and more
#
# TODO: Test and Docker Net


def exploit_manager(server_ip: str = "127.0.0.1"):
    if not server_ip:
        raise ValueError("Service IP is required")

    if not isinstance(server_ip, str):
        raise TypeError("Service IP must be a string")

    r = requests.get(f"http://{server_ip}/api/v1/config/")
    if not r.ok:
        raise Exception(f"Failed to get config from server: {r.status_code}")

    def decorator(exploit_func):
        format_ip_teams: str
        my_team_ip: str
        range_ip_teams: int
        ip_teams: list[str]

        format_ip_teams = r.json()['client']['format_ip_teams']
        range_ip_teams = r.json()['client']['range_ip_teams']
        my_team_ip = r.json()['client']['my_team_ip']

        ip_teams = [format_ip_teams.format(i) for i in range(range_ip_teams + 1)]
        ip_teams = ip_teams.remove(my_team_ip) if my_team_ip in ip_teams else ip_teams
        ip_teams = ["127.0.0.1"]

        def wrapper(*args, **kwargs):
            if 'port' not in kwargs:
                raise ValueError("Port is required")

            port = kwargs['port']

            for ip in ip_teams:
                item = {
                    'team_id': ip.split('.')[2],
                    'service_port': port,
                    'flag_code': exploit_func(ip=ip, port=port)
                }
                print(json.dumps(item))

        return wrapper

    return decorator

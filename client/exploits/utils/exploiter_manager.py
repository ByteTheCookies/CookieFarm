#!../../../venv/bin/python3

import re
import json
import time
import requests

# TODO: Implement number of threads to use - client choice
# TODO: Implement class for manageing exploit, server and more
#
# TODO: Test and Docker Net - 10.0.0.0/24



def login(server_ip: str, password: str):
    r = requests.post(f"{server_ip}/api/v1/auth/login", data={"password": password})
    if not r.ok:
        raise Exception(f"Failed to login: {r.status_code}")
    return r.json()['token']


def get_flag(text: str, regex_flag: str):
    if not isinstance(text, str):
        raise TypeError("The 'text' argument must be a string.")

    if not isinstance(regex_flag, str):
        raise TypeError("The 'regex_flag' argument must be a string.")

    if not text.strip():
        raise ValueError("The 'text' argument cannot be empty or just whitespace.")

    if not regex_flag.strip():
        raise ValueError("The 'regex_flag' argument cannot be empty or just whitespace.")

    matches = re.findall(regex_flag, text)
    return matches if matches else []


def exploit_manager(
    server_ip: str = "http://127.0.0.1:8080",
    password: str = "password",
    threads_num: int = 10,
    tick_time: int = 120,
    regex_flag: str = "^[A-Za-z0-9]{31}$",
):
    if not server_ip:
        raise ValueError("Service IP is required")

    if not isinstance(server_ip, str):
        raise TypeError("Service IP must be a string")

    token = login(server_ip, password)
    r = requests.get(f"{server_ip}/api/v1/config", headers={"Authorization": f"Bearer {token}"})
    if not r.ok:
        raise Exception(f"Failed to get config from server: {r.status_code}")

    def decorator(exploit_func):
        format_ip_teams: str
        my_team_ip: str
        range_ip_teams: int
        ip_teams: list[str]

        format_ip_teams = r.json()['client']['format_ip_teams']
        range_ip_teams = int(r.json()['client']['range_ip_teams'])
        my_team_ip = r.json()['client']['my_team_ip']

        ip_teams = [format_ip_teams.format(i) for i in range(range_ip_teams + 1)]
        ip_teams = ip_teams.remove(my_team_ip) if my_team_ip in ip_teams else ip_teams

        def wrapper(*args, **kwargs):
            if 'port' not in kwargs:
                raise ValueError("Port is required")

            port = kwargs['port']

            while True:
                start_time = time.time()

                for ip in ip_teams:
                    flags = get_flag(
                        text=exploit_func(ip=ip, port=port),
                        regex_flag=regex_flag
                    )

                    for flag in flags:
                        item = {
                            'team_id': ip.split('.')[2],
                            'service_port': port,
                            'flag_code': flag
                        }
                        print(json.dumps(item))

                elapsed_time = time.time() - start_time
                sleep_time = max(0, tick_time - elapsed_time)
                time.sleep(sleep_time)

        return wrapper

    return decorator

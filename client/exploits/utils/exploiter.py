import re
import json
import time
import asyncio

from typing import Callable


def get_flag_from_multisource(source:str|list[str], regex: re.Pattern) -> list[str]:
    if not source:
        raise ValueError("Source cannot be empty")

    if isinstance(source, list):
        if not all(isinstance(item, str) for item in source):
            raise ValueError("All items in the list must be strings")

        if not all(regex.match(item) for item in source):
            raise ValueError("All items in the list must match the flag regex")

        return source

    if not isinstance(source, str):
        raise TypeError("Source must be a string or a list of strings")

    return regex.findall(source)

async def dispatch_exploit(exploit_function:Callable, ip_team:str, port_service:int, regex: re.Pattern) -> tuple[str, list[str]]:
    return ip_team, get_flag_from_multisource(exploit_function(ip_team, port_service),regex)

async def dispatch_exploits(
    exploit_function:Callable,
    ip_teams:list[str],
    port_service:int,
    regex: re.Pattern
):
    results = await asyncio.gather(*[dispatch_exploit(exploit_function, ip_team, port_service, regex) for ip_team in ip_teams])
    for result in results:
        for flag in result[1]:
            item = {
                'team_id': int(result[0].split('.')[2]),
                'service_port': port_service,
                'flag_code': flag
            }
            print(json.dumps(item), flush=True)

def attack(
    exploit_function:Callable,
    ip_teams:list[str],
    port_service:int,
    flag_regex_format:str,
    tick_time:int
):
    while True:
        start_time = time.time()

        asyncio.run(dispatch_exploits(exploit_function, ip_teams, port_service, re.compile(flag_regex_format)))

        elapsed_time = time.time() - start_time
        sleep_time = max(0, tick_time - elapsed_time)
        time.sleep(sleep_time)

import re
from typing import Callable
import concurrent.futures as cf


class Exploiter:

    def __init__(self, flag_regex:str = "", threads:int = 1, tick:int = 60):
        self.flag_regex = flag_regex
        self.threads = threads
        self.tick = tick

    # ----- Getters -----

    @property
    def flag_regex(self) -> re.Pattern:
        return self._flag_regex

    @property
    def threads(self) -> int:
        return self._threads

    @property
    def tick(self) -> int:
        return self._tick

    # ----- Setters -----
    @flag_regex.setter
    def flag_regex(self, value):
        if not self._validate_flag_regex(value):
            self._flag_regex = re.compile(value)

    @threads.setter
    def threads(self, value):
        if not self._validate_threads(value):
            self._threads = value

    @tick.setter
    def tick(self, value):
        if not self._validate_tick(value):
            self._tick = value

    # ----- Validate -----
    def _validate_tick(self, value) -> bool:
        if not isinstance(value, int):
            raise TypeError("Tick must be an integer")
        if value <= 0:
            raise ValueError("Tick must be greater than 0")
        if not value:
            raise ValueError("Tick cannot be None")
        return True

    def _validate_threads(self, value) -> bool:
        if not isinstance(value, int):
            raise TypeError("Threads must be an integer")
        if value <= 0:
            raise ValueError("Threads must be greater than 0")
        if not value:
            raise ValueError("Threads cannot be None")
        return True

    def _validate_flag_regex(self, value) -> bool:
        if not isinstance(value, str):
            raise TypeError("Flag regex must be a string")
        if not value:
            raise ValueError("Flag regex cannot be empty")
        return True

    # ----- Methods -----
    def get_flags(self, source:str|list[str]):
        if not source:
            raise ValueError("Source cannot be empty")

        if isinstance(source, list):
            if not all(isinstance(item, str) for item in source):
                raise ValueError("All items in the list must be strings")

            if not all(self.flag_regex.match(item) for item in source):
                raise ValueError("All items in the list must match the flag regex")

            return source

        if not isinstance(source, str):
            raise TypeError("Source must be a string or a list of strings")

        matches = self.flag_regex.findall(source)
        return matches

    def __dispatch_exploit(self, ip_team: str, exploit_function: Callable[[str], str]):
        pass

    def attack(self, exploit_function:Callable[[str], str], ip_teams:list[str], service_port:str):
        if not exploit_function:
            raise ValueError("Exploit function cannot be None")

        if not ip_teams:
            raise ValueError("IP teams cannot be empty")

        if not service_port:
            raise ValueError("Service port cannot be empty")

        if not isinstance(ip_teams, list):
            raise TypeError("IP teams must be a list")

        if not all(isinstance(ip, str) for ip in ip_teams):
            raise ValueError("All IP teams must be strings")

        if not isinstance(service_port, str):
            raise TypeError("Service port must be a string")

        with cf.ThreadPoolExecutor(max_workers=self.threads) as executor:
            results = executor.map(exploit_function, ip_teams)

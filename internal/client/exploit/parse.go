// Package exploit provides functions to parse flags from JSON output.
package exploit

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/ByteTheCookies/CookieFarm/internal/client/config"
	"github.com/ByteTheCookies/CookieFarm/pkg/models"

	json "github.com/bytedance/sonic"
)

// ParseLine parses a JSON line into a Flag struct.
func ParseLine(line string) (models.ClientData, string, error) {
	cm := config.GetConfigManager()

	if strings.Contains(line, STATS) {
		var out StatusBatchOutput
		if err := json.Unmarshal([]byte(line), &out); err != nil {
			return models.ClientData{}, "invalid", fmt.Errorf("invalid JSON format: %w", err)
		}

		statusMessage := fmt.Sprintf("Service: %s (Port: %d) - Total Flags: %d - Success Teams: %d - Failed Teams: %d - Message: %s",
			out.NameService, out.PortService, out.TotalFlag, out.SuccessTeam, out.FailedTeam, out.Message)

		return models.ClientData{}, out.Status, errors.New(statusMessage)
	} else {
		var out ParsedFlagOutput
		if err := json.Unmarshal([]byte(line), &out); err != nil {
			return models.ClientData{}, "invalid", fmt.Errorf("invalid JSON format: %w", err)
		}
		switch out.Status {
		case INFO, EXPLOIT, ERROR, DEBUG, FATAL:
			return models.ClientData{}, out.Status, errors.New(out.Message)
		case FAILED:
			return models.ClientData{}, out.Status, fmt.Errorf("flag submission failed for team %d on the %s: %s",
				out.TeamID, cm.MapPortToService(out.PortService), out.Message)
		case SUCCESS:
			return models.ClientData{
				FlagCode:     out.FlagCode,
				ServiceName:  out.NameService,
				PortService:  out.PortService,
				SubmitTime:   uint64(time.Now().Unix()),
				ResponseTime: 0,
				Status:       "UNSUBMITTED",
				TeamID:       out.TeamID,
				Username:     cm.GetLocalConfig().Username,
				ExploitName:  filepath.Base(cm.GetArgsAttackInstance().ExploitPath),
				Msg:          out.Message,
			}, out.Status, nil
		default:
			return models.ClientData{}, "unknown", fmt.Errorf("unhandled status: %s", out.Status)
		}
	}
}

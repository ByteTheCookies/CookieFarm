// Package exploit provides functions to parse flags from JSON output.
package exploit

import (
	"errors"
	"fmt"
	"path/filepath"
	"strings"
	"time"

	"github.com/ByteTheCookies/CookieFarm/internal/client/config"
	"github.com/ByteTheCookies/CookieFarm/pkg/models"

	json "github.com/bytedance/sonic"
)

// ParsedFlagOutput represents the output of a parsed flag returned
// by an exploit run in the exploit_manager, ready to be submitted.
type ParsedFlagOutput struct {
	TeamID      uint16 `json:"team_id"`      // ID of the team the flag was extracted from
	PortService uint16 `json:"port_service"` // Port of the service that produced the flag
	Status      string `json:"status"`       // Status of the flag submission (eg "success", "failed", "error", "fatal")
	FlagCode    string `json:"flag_code"`    // The actual flag string
	NameService string `json:"name_service"` // Human-readable name of the service
	Message     string `json:"message"`      // Additional message or error information
}

type StatusBatchOutput struct {
	Status      string `json:"status"`       // Status of the flag submission (eg "success", "failed", "error", "fatal")
	Message     string `json:"message"`      // Additional message or error information
	NameService string `json:"name_service"` // Human-readable name of the service
	PortService uint16 `json:"port_service"` // Port of the service that produced the flag
	TotalFlag   int    `json:"total_flag"`   // Total flag collected in the batch
	SuccessTeam int    `json:"success_team"` // Total number of teams from which flags were successfully extracted
	FailedTeam  int    `json:"failed_team"`  // Total number of teams from which flag extraction failed
}

const (
	INFO    = "info"         // Status indicating informational output
	EXPLOIT = "exploit_info" // Status indicating exploit-specific informational output
	FAILED  = "failed"       // Status indicating flag submission failure
	ERROR   = "error"        // Status indicating a general error in flag submission
	FATAL   = "fatal"        // Status indicating a fatal error in the exploiter
	SUCCESS = "success"      // Status indicating successful flag submission
	STATS   = "stats"        // Status indicating a batch of statistics
	DEBUG   = "debug"        // Status indicating debug information
)

// ParseLine parses a JSON line into a Flag struct.
func ParseLine(line string) (models.ClientData, string, error) {
	cm := config.GetConfigManager()

	if strings.Contains(line, STATS) {
		var out StatusBatchOutput
		if err := json.Unmarshal([]byte(line), &out); err != nil {
			return models.ClientData{}, "invalid", fmt.Errorf("invalid JSON format: %w", err)
		}

		statusMessage := fmt.Sprintf("Service: %s (Port: %d) - Total Flags: %d - Success Teams: %d - Failed Teams: %d - Message: %s",
			out.NameService, out.PortService, out.TotalFlag, out.SuccessTeam, out.FailedTeam, out.Message)

		return models.ClientData{}, out.Status, errors.New(statusMessage)
	} else {
		var out ParsedFlagOutput
		if err := json.Unmarshal([]byte(line), &out); err != nil {
			return models.ClientData{}, "invalid", fmt.Errorf("invalid JSON format: %w", err)
		}
		switch out.Status {
		case INFO, EXPLOIT:
			return models.ClientData{}, out.Status, errors.New(out.Message)
		case FAILED:
			return models.ClientData{}, out.Status, fmt.Errorf("flag submission failed for team %d on the %s: %s",
				out.TeamID, cm.MapPortToService(out.PortService), out.Message)
		case ERROR:
			return models.ClientData{}, out.Status, fmt.Errorf("flag submission error: %s", out.Message)
		case FATAL:
			return models.ClientData{}, out.Status, fmt.Errorf("fatal error in the exploiter: %s", out.Message)
		case DEBUG:
			return models.ClientData{}, out.Status, fmt.Errorf("debug information: %s", out.Message)
		case SUCCESS:
			return models.ClientData{
				FlagCode:     out.FlagCode,
				ServiceName:  out.NameService,
				PortService:  out.PortService,
				SubmitTime:   uint64(time.Now().Unix()),
				ResponseTime: 0,
				Status:       "UNSUBMITTED",
				TeamID:       out.TeamID,
				Username:     cm.GetLocalConfig().Username,
				ExploitName:  filepath.Base(cm.GetArgsAttackInstance().ExploitPath),
				Msg:          out.Message,
			}, out.Status, nil
		default:
			return models.ClientData{}, "unknown", fmt.Errorf("unhandled status: %s", out.Status)
		}
	}
}

// Package cmd contains commands for the CookieFarm client
package cmd

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/ByteTheCookies/CookieFarm/internal/client/config"
	"github.com/ByteTheCookies/CookieFarm/internal/client/exploit"
	"github.com/ByteTheCookies/CookieFarm/internal/client/websockets"
	"github.com/ByteTheCookies/CookieFarm/pkg/logger"
	"github.com/ByteTheCookies/CookieFarm/pkg/models"
	"github.com/rs/zerolog"
	"github.com/spf13/cobra"
)

var (
	exploitPath string // Path to the exploit file to execute
	detach      bool   // Run the exploit in the background (detached mode)
	tickTime    int    // Interval in seconds between exploit executions
	threadCount int    // Number of concurrent threads to run the exploit with
	submitValue bool   // This flag is used to directly submit to the game server
	exploitName string // Name of the exploit template to create or remove
	pid         int    // PID of the exploit to stop
	flag        string // Path to the exploit file to execute (used in submit command, not run command)
	serviceName string // Service name for the submit command
	teamID      uint16 // Service name and team ID for the submit command
	message     string // Message to include with the submission (optional, can be empty or omitted)
)

// ExploitCmd represents the main exploit command group
// Exported for TUI usage
var ExploitCmd = &cobra.Command{
	Use:   "exploit",
	Short: "Handling exploits and executing them in a loop",
	Long:  `This command allows you to handle exploits (execute, create, etc.). You can specify the exploit path, service port, and other parameters.`,
}

// runCmd represents the run exploit command
var runCmd = &cobra.Command{
	Use:   "run",
	Short: "Attack other teams with an exploit",
	Long:  `This command allows you to attack other teams with an exploit. You can specify the exploit path and the server host.`,
	Run:   run,
}

// runCmd represents the run exploit command
var testCmd = &cobra.Command{
	Use:   "test",
	Short: "Test the exploit on the NOP team",
	Long:  `This command allows you to test an exploit against the NOP team to verify it works correctly before running it against other teams in the competition.`,
	Run:   test,
}

// createCmd represents the create exploit command
var createCmd = &cobra.Command{
	Use:   "create",
	Short: "Generate a new exploit template",
	Long: `Generate a new exploit template for the CookieFarm client.
	This command initializes a structured exploit template file in your specified directory with all necessary components for immediate use.`,
	Run: create,
}

// listCmd represents the list exploit command
var listCmd = &cobra.Command{
	Use:   "list",
	Short: "List all current running exploits",
	Long:  "This command lists all currently running exploits that are registered in the local configuration.",
	Run:   list,
}

// removeCmd represents the remove exploit command
var removeCmd = &cobra.Command{
	Use:   "remove",
	Short: "Remove an exploit template",
	Long:  `Remove an exploit template from the CookieFarm client.`,
	Run:   remove,
}

// stopCmd represents the stop exploit command
var stopCmd = &cobra.Command{
	Use:   "stop",
	Short: "Stop the exploit execution",
	Long:  `This command stops the execution of the currently running exploit. It gracefully terminates the exploit process and cleans up any resources used during execution.`,
	Run:   stop,
}

// createCmd represents the create exploit command
var submitCmd = &cobra.Command{
	Use:   "submit",
	Short: "Send a new flag to the game server",
	Long:  `This command allows you to submit a new flag to the game server.`,
	Run:   submit,
}

func init() {
	// Add ExploitCmd to root command
	RootCmd.AddCommand(ExploitCmd)

	// Add all subcommands to ExploitCmd
	ExploitCmd.AddCommand(runCmd)
	ExploitCmd.AddCommand(testCmd)
	ExploitCmd.AddCommand(createCmd)
	ExploitCmd.AddCommand(stopCmd)
	ExploitCmd.AddCommand(listCmd)
	ExploitCmd.AddCommand(removeCmd)
	ExploitCmd.AddCommand(submitCmd)

	// Setup flags for attackCmd (run)
	runCmd.Flags().StringVarP(&exploitPath, "exploit", "e", "", "Path to the exploit file to execute")
	runCmd.Flags().StringVarP(&serviceName, "name", "n", "", "Service name to attack")
	runCmd.Flags().BoolVarP(&detach, "detach", "d", false, "Run the exploit in the background (detached mode)")
	runCmd.Flags().IntVarP(&tickTime, "tick", "t", 120, "Interval in seconds between exploit executions")
	runCmd.Flags().IntVarP(&threadCount, "thread", "T", 5, "Number of concurrent threads to run the exploit with")
	runCmd.Flags().BoolVarP(&submitValue, "submit", "S", false, "Direct submit to the game server")
	runCmd.MarkFlagRequired("exploit")
	runCmd.MarkFlagRequired("port")
	runCmd.MarkFlagRequired("host")

	testCmd.Flags().StringVarP(&exploitPath, "exploit", "e", "", "Path to the exploit file to execute")
	testCmd.Flags().StringVarP(&serviceName, "name", "n", "", "Service name to attack")
	testCmd.Flags().BoolVarP(&detach, "detach", "d", false, "Run the exploit in the background (detached mode)")
	testCmd.Flags().IntVarP(&tickTime, "tick", "t", 120, "Interval in seconds between exploit executions")
	testCmd.Flags().IntVarP(&threadCount, "thread", "T", 5, "Number of concurrent threads to run the exploit with")
	testCmd.MarkFlagRequired("exploit")
	testCmd.MarkFlagRequired("port")
	testCmd.MarkFlagRequired("host")

	// Setup flags for createCmd
	createCmd.Flags().StringVarP(&exploitName, "name", "n", "", "Name of the exploit template")
	createCmd.MarkFlagRequired("name")

	// Setup flags for removeCmd
	removeCmd.Flags().StringVarP(&exploitName, "name", "n", "", "Name of the exploit template")
	removeCmd.MarkFlagRequired("name")

	// Setup flags for stopCmd
	stopCmd.Flags().IntVarP(&pid, "pid", "p", -1, "Pid to the exploit file to stop")
	stopCmd.MarkFlagRequired("pid")

	submitCmd.Flags().StringVarP(&exploitPath, "flag", "f", "", "Path to the exploit file to execute")
	submitCmd.Flags().StringVarP(&serviceName, "name", "n", "", "Service name to attack")
	submitCmd.Flags().Uint16VarP(&teamID, "team", "t", 0, "Team ID for the submit command")
	submitCmd.Flags().StringVarP(&message, "message", "m", "", "Message to include with the submission (optional)")
	submitCmd.MarkFlagRequired("flag")
}

func Run(isTest bool) error {
	cm := config.GetConfigManager()
	cm.SetArgsAttackInstance(config.ArgsAttack{
		ServiceName: serviceName,
		TickTime:    tickTime,
		ThreadCount: threadCount,
		Detach:      detach,
		ExploitPath: exploitPath,
	})

	logger.Log.Debug().Str("ExploitPath", cm.GetArgsAttackInstance().ExploitPath).
		Int("TickTime", cm.GetArgsAttackInstance().TickTime).
		Int("ThreadCount", cm.GetArgsAttackInstance().ThreadCount).
		Str("ServicePort", cm.GetArgsAttackInstance().ServiceName).
		Msg("Starting exploit execution with parameters")

	c := make(chan os.Signal, 1)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go exploit.ShutdownGrafefully(c, cm)

	if err := exploit.Setup(detach); err != nil {
		if logger.LogLevel != zerolog.Disabled {
			logger.Log.Fatal().Err(err).Msg("Initialization error")
			logger.Close()
		} else {
			fmt.Println("Error initializing:", err)
		}
		os.Exit(1)
	}
	defer logger.Close()

	logger.Log.Info().Msg("Client initialized successfully")

	result, err := exploit.Start(
		cm.GetArgsAttackInstance().ExploitPath,
		tickTime,
		threadCount,
		serviceName,
		isTest,
	)
	if err != nil {
		logger.Log.Fatal().Err(err).Msg("Failed to execute exploit")
	}

	exploitS := config.Exploit{
		Name: exploitPath,
		PID:  result.Cmd.Process.Pid,
	}
	localConfig := cm.GetLocalConfig()
	localConfig.Exploits = append(localConfig.Exploits, exploitS)

	if _, err := cm.SetLocalConfig(localConfig); err != nil {
		logger.Log.Fatal().Err(err).Msg("Failed to write configuration with new exploit")
	}
	cm.SetPID(result.Cmd.Process.Pid)
	logger.Log.Info().Msg("Exploit started successfully")

	websockets.OnNewConfig = func() {
		exploit.RestartGlobal()
	}

	if submitValue {
		go exploit.SubmitFlags(result.FlagsChan)
	} else {
		go websockets.Start(result.FlagsChan)
	}

	if err := result.Cmd.Wait(); err != nil {
		logger.Log.Error().Err(err).Msg("Exploit process exited with error")
		return err
	}

	return nil
}

func test(cmd *cobra.Command, args []string) {
	if err := Run(true); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to execute exploit test")
		fmt.Println("Error executing exploit test:", err)
		return
	}
}

// ===== RUN EXPLOIT FUNCTIONS =====

// run is the main execution flow for the run command (this function is specific to the run command, instead use exploit.Run)
func run(cmd *cobra.Command, args []string) {
	if err := Run(false); err != nil {
		logger.Log.Error().Err(err).Msg("Failed to execute exploit test")
		fmt.Println("Error executing exploit test:", err)
		return
	}
}

// ===== CREATE EXPLOIT FUNCTIONS =====

// create handles the creation of a new exploit template
func create(cmd *cobra.Command, args []string) {
	res, err := exploit.Create(exploitName)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error creating exploit")
		return
	} else {
		logger.Log.Info().Msg(res)
	}
}

// ===== LIST EXPLOIT FUNCTIONS =====

// list lists all currently running exploits
func list(cmd *cobra.Command, args []string) {
	res, err := exploit.List()
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error listing exploits")
		fmt.Println("Error listing exploits:", err)
		return
	} else {
		logger.Log.Info().Msg(res)
	}
}

// ===== REMOVE EXPLOIT FUNCTIONS =====

// remove handles the removal of an exploit template
func remove(cmd *cobra.Command, args []string) {
	res, err := exploit.Remove(exploitName)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error removing exploit")
		return
	} else {
		logger.Log.Info().Msg(res)
	}
}

// ===== STOP EXPLOIT FUNCTIONS =====

// stop stops a running exploit by PID
func stop(cmd *cobra.Command, args []string) {
	cm := config.GetConfigManager()
	cm.SetPID(pid)
	res, err := exploit.Stop(pid)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error stopping exploit")
		return
	} else {
		logger.Log.Info().Msg(res)
	}
}

func submit(cmd *cobra.Command, args []string) {
	cm := config.GetConfigManager()
	cm.LoadLocalConfigFromFile()
	if token, err := cm.GetSession(); err != nil {
		logger.Log.Error().Err(err).Msg("Error getting session token")
		return
	} else {
		cm.SetToken(token)
		logger.Log.Debug().Str("token", token).Msg("Token set for submission")
	}

	clientData := models.ClientData{
		FlagCode:     flag,
		ServiceName:  serviceName,
		PortService:  cm.MapServiceToPort(serviceName),
		SubmitTime:   uint64(time.Now().Unix()),
		ResponseTime: 0,
		Status:       "UNSUBMITTED",
		TeamID:       teamID,
		Username:     cm.GetLocalConfig().Username,
		ExploitName:  exploitName,
		Msg:          message,
	}

	res, err := exploit.SubmitFlag(clientData)
	if err != nil {
		logger.Log.Error().Err(err).Msg("Error submitting exploit")
		return
	} else {
		logger.Log.Info().Msg(res)
	}
}
